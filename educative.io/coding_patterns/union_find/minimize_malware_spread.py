"""
You are given a network of n nodes as an nxn adjacency matrix graph with the ith node connected to jth node if graph[i][j]= 1


A list of nodes, initial, is given, which contains nodes initially infected by malware. When two nodes are connected directly and at least one of them is infected by malware, both nodes will be infected by malware. This spread of malware will continue until every node in the connected component of nodes has been infected.

After the infection has stopped spreading, M will represent the final number of nodes in the entire network that have been infected with malware.

Return a node from initial such that, when this node is removed from the graph, M is minimized. If multiple nodes can be removed to minimize M, return the node with the smallest index.

"""

class UnionFind:
    # Constructor
    def __init__(self, n):
        self.parent = list(range(n))
        self.rank = [1]*n

    # Function to find which subset a particular element belongs.
    def find(self, i):
        if self.parent[i] != i:
            self.parent[i] = self.find(self.parent[i])
        return self.parent[i]

    # Function to join two subsets into a single subset.
    def union(self, x, y):
        root_x, root_y = map(self.find, (x, y))
        if root_x == root_y:
            return
        small, big = sorted([root_x, root_y], key=lambda z: self.rank[z])
        self.parent[small] = big
        self.rank[big] += self.rank[small]


from collections import Counter


def min_malware_spread(graph, initial):
  # Your code will replace this placeholder return statement
  n = len(graph)
  union_find = UnionFind(n)

  # create connected components set
  for x in range(n):
    for y in range(n):
      if graph[x][y]:
        union_find.union(x, y)
  
  # find the initial infected node
  infected = Counter()
  for x in initial:
    infected[union_find.find(x)] += 1
  

  max_size, candidate_node = 0, min(initial)

  # count all infected nodes each connected component has
  for i in initial:
    root_i = union_find.find(i)
    infection_count = infected[root_i]
    component_size = union_find.rank[root_i]

    if infection_count != 1:
      continue
    
    # return candidate node from the largest connected component
    if component_size > max_size:
      max_size = component_size
      candidate_node = i
    elif component_size == max_size and i < candidate_node:
      candidate_node = i
  
  return candidate_node



def main():
    graph = [[[1, 1, 1], [1, 1, 1], [1, 1, 1]],
            [[1, 1, 0],[1, 1, 0], [0, 0, 1]],
            [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
            [[1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [1, 1, 1, 0, 1]],
            [[1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [1, 1, 1, 0, 1]]]
    initial = [[1, 2], [0, 1], [0, 2], [2, 3], [3, 4]]
    for i in range(0, len(initial)):
        print(i+1, ".\tgraph = ", graph[i], ", ", "Initial = ", initial[i], sep="")
        print("\n\tThe node which minimizes malware spread is", min_malware_spread(graph[i], initial[i]))
        print("-"*100)


if __name__ == '__main__':
    main()